# Software Enginnering

### 1. 등가분할 기법(Equivalence Partitioning)

소프트웨어 테스트 설계 기법 중 하나로, **입력값을 의미 있는 그룹으로 나누어 각 그룹(분할)에 대해 최소한의 테스트만 수행**하여 효율적인 테스트를 가능하게 함

블랙박스 테스트(Black-box testing)의 대표적인 기법 중 하나로, **불필요한 중복 테스트를 줄이고, 테스트 케이스 수를 최적화**할 수 있음

---

#### 정의

**입력 도메인을 등가 클래스(Equivalence Class)로 나누고**, 각 클래스에서 **대표값을 선택하여 테스트하는 기법**

- 같은 등가 클래스에 속하는 값들은 시스템이 **같은 방식으로 처리한다고 간주
- 따라서, **각 등가 클래스에서 하나의 값만 테스트**해도 충분

---

#### 등가 클래스(Equivalence Class)의 유형

| 유형                        | 설명               | 예시                  |
| --------------------------- | ------------------ | --------------------- |
| 유효 클래스 (Valid Class)   | 올바른 입력값 범위 | 나이: 0~120           |
| 무효 클래스 (Invalid Class) | 잘못된 입력값 범위 | 나이: -1, 121 이상 등 |

---

#### 예시

어떤 입력 필드가 **1부터 100까지의 정수만 허용**된다고 가정

- 이 입력값의 등가 분할은 다음과 같음:

| 등가 클래스     | 설명          | 예시            |
| --------------- | ------------- | --------------- |
| 무효 클래스 1   | 1보다 작은 값 | -10, 0          |
| **유효 클래스** | 1 ~ 100       | **50** (대표값) |
| 무효 클래스 2   | 100보다 큰 값 | 101, 999        |

각 클래스로부터 대표 값을 하나씩 선택해 총 **3개의 테스트 케이스**를 만들 수 있음

---

#### 장점

| 장점                  | 설명                                                  |
| --------------------- | ----------------------------------------------------- |
| 테스트 케이스 수 감소 | 입력값을 대표값으로 대체하므로 중복을 줄이고 효율적   |
| 테스트 시간 절감      | 모든 값 테스트 대신 각 클래스별 대표값만 검증         |
| 구조적 테스트 설계    | 유효/무효 등가 클래스를 구분하여 체계적인 테스트 가능 |
| 다른 기법과 결합 쉬움 | 경계값 분석 등과 함께 사용 시 시너지 효과             |

---

#### 단점

| 단점                              | 설명                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| 경계값 오류 탐지 어려움           | 등가 클래스의 **대표값만** 사용하기 때문에, **경계 인접 값에서 발생하는 오류**를 놓치기 쉬움 → **경계값 분석(BVA)** 필요 |
| 대표값의 선택 문제                | 등가 클래스 내 대표값을 잘못 고르면, **결함을 놓칠 수 있음** |
| 복잡한 입력 구조 처리 한계        | 다중 입력 조합(예: 날짜, 시간 등)에서는 단일 입력 기준 등가분할이 **불충분**할 수 있음 |
| 무효 입력 탐지 범위 제한          | 유효 범위 밖을 무효 클래스로 처리하더라도, **비정상 입력의 모든 경우를 포착하긴 어려움** |
| 논리적 흐름 기반 결함 탐지 어려움 | 내부 로직에 따른 복잡한 흐름이나 **조건 분기 기반 결함 탐지는 제한적** |

---

#### 등가분할 vs 경계값 분석 비교

| 항목        | 등가분할 기법              | 경계값 분석 기법    |
| ----------- | -------------------------- | ------------------- |
| 초점        | 전체 입력 영역을 나누는 것 | 경계 근처 값에 집중 |
| 테스트 대상 | 각 클래스의 대표값         | 경계값 전후의 값들  |
| 예시        | 1~100 → 50                 | 0, 1, 100, 101 등   |

---

### 2. 경계값 분석 기법 (Boundary Value Analysis, BVA)

소프트웨어 테스트 설계 기법 중 하나로, **입력값의 경계 근처에 오류가 집중된다는 경험적 사실에 기반**하여, **각 경계의 바로 전/후 값을 테스트**하는 방식

등가분할 기법과 함께 사용되는 블랙박스 테스트(Black-box Testing)의 대표적인 기법으로, **경계 인접 값에서 발생하는 결함을 효과적으로 발견**할 수 있음

---

#### 정의

**입력값의 유효한 범위의 경계값 전후를 중심으로 테스트 케이스를 설계**하는 기법

- 사람은 보통 **경계 처리 시 실수**하기 쉬움 → 결함이 자주 발생
- 따라서 **최솟값, 최댓값과 그 직전/직후 값들을 집중적으로 테스트**

---

#### 경계값 유형

| 경계 유형    | 설명                          | 예시         |
| ------------ | ----------------------------- | ------------ |
| 유효 경계값  | 정상 입력 범위의 최소/최대 값 | 나이: 1, 100 |
| 경계 인접 값 | 유효 범위 바로 바깥의 무효 값 | 나이: 0, 101 |

---

#### 예시

입력값이 **1부터 100까지의 정수만 허용**된다고 가정할 때,
경계값 분석은 다음과 같은 값들을 테스트:

| 테스트 값 | 설명                 | 기대 결과 |
| --------- | -------------------- | --------- |
| 0         | 최소값보다 1 작은 값 | 오류      |
| 1         | 최소값               | 정상      |
| 2         | 최소값보다 1 큰 값   | 정상      |
| 99        | 최대값보다 1 작은 값 | 정상      |
| 100       | 최대값               | 정상      |
| 101       | 최대값보다 1 큰 값   | 오류      |

➡ 총 6개의 경계값 기반 테스트 케이스 도출

---

#### 장점

| 장점                       | 설명                                                         |
| -------------------------- | ------------------------------------------------------------ |
| 경계 오류 탐지에 효과적    | 사람은 경계값 처리에서 실수를 많이 하므로, 결함 발견율이 높음 |
| 등가분할 보완 가능         | 등가분할 기법이 놓칠 수 있는 경계 인접 오류를 보완           |
| 중요한 최소/최대 처리 검증 | 경계값은 실제 시스템에서 자주 문제가 되는 포인트로, 품질 확보에 중요 |

---

#### 단점

| 단점                           | 설명                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 테스트 케이스 수 증가 가능성   | 모든 경계에 대해 전/후 값을 포함하면 케이스 수가 많아질 수 있음 |
| 다중 입력 변수 처리 복잡       | 여러 입력 조건이 있을 경우, 경계 조합이 급격히 늘어나 테스트 설계가 어려움 |
| 대표성 있는 일반값 테스트 부족 | 경계만 집중적으로 테스트하면 **중간값 범위의 일반적인 처리 오류를 놓칠 수 있음** |

---

#### 등가분할 vs 경계값 분석 비교

| 항목        | 등가분할 기법                 | 경계값 분석 기법                      |
| ----------- | ----------------------------- | ------------------------------------- |
| 초점        | 입력값 전체를 클래스별로 나눔 | 각 클래스의 **경계값 주변**에 집중    |
| 테스트 대상 | 각 클래스의 **대표값**        | 경계값과 **그 전/후 값**              |
| 테스트 수   | 클래스 수에 비례하여 적음     | 경계 수에 따라 많아질 수 있음         |
| 예시        | 1~100 중 50                   | 0, 1, 2, 99, 100, 101                 |
| 장점        | 테스트 효율성, 중복 제거      | 결함 발생 가능성이 높은 경계에 효과적 |
| 단점        | 경계 오류 탐지 어려움         | 일반 처리 로직의 오류 탐지는 약함     |

---

### 3. 요구사항 도출 기법(Requirement Elicitation Techniques)

### 정의

시스템이 충족해야 할 요구사항을 **이해관계자와의 소통이나 분석을 통해 수집하는 활동**
 하나의 기법으로 충분하지 않으며, **복합적으로 활용**해야 신뢰성 있는 요구 도출 가능

------

### 대표 기법 및 비교

| 기법                              | 설명                                    | 장점                     | 단점                   | 활용 예               |
| --------------------------------- | --------------------------------------- | ------------------------ | ---------------------- | --------------------- |
| **인터뷰**                        | 사용자 또는 전문가에게 직접 질문        | 심층 정보 수집 가능      | 주관성, 시간 소요      | 관리자 인터뷰         |
| **설문조사**                      | 구조화된 질문지를 통해 다수의 응답 수집 | 정량적 데이터 확보       | 얕은 정보, 설계 어려움 | UX 만족도             |
| **관찰 / 현장조사 (Observation)** | 사용자의 실제 작업을 관찰               | 실제 사용 방식 이해 가능 | 시간·비용 소요         | 병원 업무 관찰        |
| **워크숍 / 브레인스토밍**         | 여러 이해관계자와 함께 아이디어 도출    | 창의성, 공감대 형성      | 수렴 어려움            | 서비스 개선 논의      |
| **문서분석**                      | 기존 정책, 매뉴얼, 시스템 문서 분석     | 빠른 초기 이해           | 현실과 불일치 가능성   | 기존 시스템 정책 확인 |

---

### 4. 기능 요구사항 vs 비기능 요구사항

#### 정의

| 분류            | 설명                                            | 예시                        |
| --------------- | ----------------------------------------------- | --------------------------- |
| 기능 요구사항   | 시스템이 **무엇을 해야 하는가**                 | 로그인, 검색, 장바구니 추가 |
| 비기능 요구사항 | 시스템이 **어떻게 작동해야 하는가** (품질 기준) | 응답시간, 보안, 접근성 등   |

---

#### 비교

| 항목      | 기능 요구사항      | 비기능 요구사항                |
| --------- | ------------------ | ------------------------------ |
| 목적      | 기능 구현          | 품질 보장                      |
| 작성 방식 | "무엇을 할 것인가" | "어떤 조건 하에 동작할 것인가" |
| 검증 방법 | 시나리오 테스트    | 성능 측정, 품질 평가 등        |

---

### 5. 테스트 가능성 (Testability)

#### 정의

요구사항은 **테스트 가능한 형태로 명확히 기술되어야 하며**, 추상적 표현은 테스트 기준을 만들기 어려움

---

#### 좋은 요구사항 작성 예

| 나쁜 예                     | 좋은 예                       |
| --------------------------- | ----------------------------- |
| 시스템이 빠르게 동작해야 함 | 응답시간 2초 이내로 결과 반환 |
| 사용자 불만이 없도록 한다   | 실패율 1% 이하로 유지         |

---

### 6. Agile 핵심 개념: Sprint, User Story, 회고, Demo

#### 핵심 구성요소

| 요소              | 설명                                              | 활용 목적         |
| ----------------- | ------------------------------------------------- | ----------------- |
| **Sprint**        | 정해진 기간(보통 2주)의 반복 개발 주기            | 점진적 개발       |
| **User Story**    | 사용자 중심의 요구 표현 ("나는 ~로서 ~하고 싶다") | 요구사항 정의     |
| **Demo**          | 스프린트 종료 후 결과물 시연                      | 이해관계자와 공유 |
| **Retrospective** | 개발 프로세스 개선 회의                           | 지속적 품질 향상  |

---

#### 상호작용 구조

1. User Story 선정
2. Sprint 동안 개발
3. Demo로 산출물 공유
4. 회고(Retrospective)로 개선 사항 도출
5. 다음 Story 우선순위 재조정

---

### 7. 인터페이스 정의서 구성 요소

| 항목                   | 설명                           |
| ---------------------- | ------------------------------ |
| **API 경로 및 메서드** | 예: `/payment/confirm` - POST  |
| **요청(Request)**      | 입력 필드명, 타입, 필수 여부   |
| **응답(Response)**     | 반환 코드, 메시지, 데이터 구조 |
| **예시(JSON)**         | 실제 입력/출력 예시 포함       |

---

### 8. 결정 테이블 (Decision Table)

#### 정의

**모든 조건 조합**에 대해 **시스템의 행동을 표 형태로 정의**하여 **누락과 충돌을 방지**하는 기법.

---

#### 구성 요소

| 구성    | 설명                                 |
| ------- | ------------------------------------ |
| 조건    | 입력 조건 (예: 회원 등급, 결제 수단) |
| 조건 값 | 조건별 값 (일반/프리미엄, 카드 등)   |
| 행동    | 결과 (할인율, 서비스 등)             |
| 행동 값 | 행동 실행 여부                       |

---

#### 예시

| 회원등급 | 결제수단 | 할인율 | 사은품 |
| -------- | -------- | ------ | ------ |
| 일반     | 카드     | 5%     | X      |
| 일반     | 계좌이체 | 5%     | O      |
| 프리미엄 | 카드     | 10%    | X      |
| 프리미엄 | 계좌이체 | 10%    | O      |

---

#### 장단점

| 장점                     | 단점                    |
| ------------------------ | ----------------------- |
| 조건 누락 방지           | 조건 많아지면 조합 폭증 |
| 명확한 커뮤니케이션 수단 | 작성 어려움, 도출 복잡  |

---

### 9. 실시간 처리(Online) vs 배치 처리(Batch)

#### 실시간 처리(Online Interface)

- **정의**: 요청 시 즉시 응답하는 데이터 처리 방식
- **특징**
  - 낮은 지연 시간(Latency)
  - 요청-응답 구조
  - 사용자 경험(UX)과 직결
- **예시**: 로그인, 결제 승인, 주문 확인

---

#### 배치 처리(Batch Interface)

- **정의**: 대량의 데이터를 일정 주기로 모아 한 번에 처리.
- **특징**
  - 처리 효율·성능 최적화
  - 스케줄 기반 실행
- **예시**: 일일 리포트, 월말 마감, 데이터 마이그레이션

---

#### 비교

| 구분      | 실시간       | 배치             |
| --------- | ------------ | ---------------- |
| 처리 시점 | 요청 시 즉시 | 특정 주기        |
| 장점      | UX 향상      | 대용량 효율 처리 |
| 단점      | 부하 증가    | 최신성 떨어짐    |

---

### 10. 데이터 표준화와 구조 설계

#### 데이터 표준화(Data Standardization)

- **정의**: 시스템 전반에서 데이터 명칭, 형식, 코드 값을 일관되게 정의
- **목적**: 호환성, 유지보수성, 오류 감소
- **표준**: ISO/IEC 11179 메타데이터 표준

---

#### 도메인 설계(Domain Modeling)

- **정의**: 특정 업무 영역의 데이터 구조와 제약 정의
- **관련 개념**: ERD(Entity Relationship Diagram), 데이터 무결성

---

#### JSON(JavaScript Object Notation)

- **정의**: 경량 데이터 교환 포맷(RFC 8259)
- **특징**: Key-Value, 배열, 중첩 객체, 언어 독립적
- **반대 개념/대안**: XML, Protocol Buffers(Protobuf), YAML

---

### 11. 출력 데이터(Out Data)와 입력 데이터(In Data) 설계

#### Out 데이터 설계 원칙

- **핵심**: 하위 호환성 유지, 구조 단순화, 필드 최소화
- **모범사례**: 핵심 식별자 + 상태코드만 반환, 세부 데이터는 별도 API
- **위험**: 모든 상세 데이터를 한 번에 반환 → 변경 영향 커짐

---

#### In 데이터 설계 원칙

- **핵심**: 필수/선택 구분, 배열 처리 원칙
- **JSON Schema**: `required` 속성, 데이터 타입 명시
- **위험**: 선택 항목 미명시 시 파싱 오류·호환성 문제 발생

---

### 12. 복합 데이터 구조 설계와 확장성

#### 복합 데이터 처리

- **문제 상황**: 텍스트 + 이미지 + 동영상 같이 서로 다른 타입을 하나의 응답에 포함

- **해결책**: 각 항목에 `type` 필드 명시

- **예시**:

  ```json
  [
    { "type": "text", "value": "Hello" },
    { "type": "image", "url": "https://..." }
  ]
  ```

---

#### 데이터 그룹 구조 설계

- **Wrapper Object 방식**: 모든 그룹을 상위 객체에 포함 (`menu.coffees`, `menu.breads`)
- **Resource 분리 방식**: 최상위에 각각의 그룹(`coffees`, `breads`)
- **반대 개념**: 동적 구조(Dynamic Schema) → 필드 구성이 요청마다 달라짐 (비권장)

---

### 13. 요구사항 분석과 검증

#### 요구사항 분석

- **정의**: 시스템이 수행해야 할 기능/비기능 요구를 도출
- **도출 기법**: 인터뷰, 설문, 관찰, 워크숍, 문서분석
- **연관 개념**: 기능 요구사항 vs 비기능 요구사항, 유스케이스(Use Case)

---

#### 검증(Validation)

- **목적**: 요구사항 정의서와 설계 산출물의 일관성, 완전성 확인
- **기법**
  - 리뷰(Review)
  - 워크스루(Walkthrough)
  - 인스펙션(Inspection)
- **반대 개념**: Verification(검증)과 Validation(확인)의 차이
  - Verification: "제대로 만들었는가?"(설계·코드 검토)
  - Validation: "올바른 것을 만들었는가?"(요구사항 충족 여부 확인)

---

### 14. 업무흐름도와 역할자

#### 업무흐름도(Business Process Flow)

- **표준**: BPMN 2.0
- **오류 유형**: 흐름 누락, 잘못된 역할자, 조건 분기 오류, 중복 단계
- **수정 방법**: 표준 기호 재작성, 로직 재검토, 단계 병합

---

#### 역할자(Role)

- **정의**: 프로세스 단계별 책임 주체
- **세분화 필요**: 권한, 데이터 접근 범위, 업무 책임이 다른 경우
- **연관 개념**: RACI 매트릭스, Actor(UML)

---

### 15. MSA·분산 트랜잭션·CQRS·SAGA 핵심 정리

#### 일관성 모델

| 구분 | Strong Consistency                     | Eventual Consistency       |
| ---- | -------------------------------------- | -------------------------- |
| 정의 | 트랜잭션 후 모든 노드가 즉시 동일 상태 | 일정 시간 후 데이터가 일치 |
| 장점 | 데이터 신뢰성↑                         | 확장성↑, 가용성↑           |
| 단점 | 지연↑, 확장성↓                         | 읽기 시점 불일치 가능      |
| 예시 | 단일 DB 트랜잭션, 2PC                  | SAGA, CQRS, Event Sourcing |

------

#### 분산 트랜잭션 처리 방식 비교

| 구분      | SAGA                   | 2PC (Two-Phase Commit)            | TCC (Try-Confirm-Cancel) |
| --------- | ---------------------- | --------------------------------- | ------------------------ |
| 적용 환경 | MSA, 분산 시스템       | 단일 DB / tightly coupled 분산 DB | 금전·재고·예약 등        |
| 일관성    | 최종 일관성            | 강한 일관성                       | 강한 일관성(예약 기반)   |
| 장애 복구 | 보상 트랜잭션          | 롤백                              | 예약 취소                |
| 확장성    | 높음                   | 낮음(글로벌 락)                   | 중간                     |
| 장점      | 서비스 독립성, 확장성↑ | 데이터 신뢰성, 즉시 일관성        | 이중 소비 방지           |
| 단점      | 보상 불가 작업 존재    | 성능 저하(락)                     | 구현 난이도↑             |

------

#### SAGA 패턴 유형 비교

| 구분      | Choreography                             | Orchestration                        |
| --------- | ---------------------------------------- | ------------------------------------ |
| 제어 방식 | 이벤트 기반, 각 서비스 자율 실행         | 중앙 오케스트레이터가 순서·보상 제어 |
| 장점      | 낮은 결합도, 유연 확장                   | 흐름·장애 추적 용이, 가시성↑         |
| 단점      | 이벤트 폭증, 순환 의존 위험, 추적 어려움 | 중앙 의존성↑, SPOF 위험              |
| 적합      | 간단한 플로우                            | 복잡한 플로우, 장애 추적 필요        |

------

#### CQRS 핵심

- **정의**: Command(쓰기)와 Query(읽기) 모델 분리
- **장점**: 쓰기/읽기 성능 최적화, 읽기 모델 자유 설계
- **단점**: 데이터 최종 일관성, 이벤트 중복 처리 필요
- **성능 최적화**:
  - 전용 인덱스, 캐시 계층(Redis, Memcached)
  - Materialized View
  - Write-through / Write-behind 캐싱
- **주의사항**:
  - 멱등성 구현 필수
  - 이벤트 순서 보장 전략 필요

------

#### Event Sourcing 핵심

- **정의**: 상태를 이벤트 로그로 저장, 재생(Replay) 가능
- **장점**: 장애 복구·재구성 용이, 모든 변경 이력 보관
- **단점**: 구현 복잡, 스냅샷·버전 관리 필요
- **필수 고려사항**:
  - 멱등성 보장
  - 스냅샷 활용으로 복구 속도 개선
  - 이벤트 버전 관리

------

#### 멱등성(Idempotency) 구현 패턴

1. **Idempotency Key**: 요청마다 고유 키 부여, 처리 기록 저장
2. **Inbox Table**: 수신 이벤트 ID 기록 → 중복 시 무시
3. **Outbox Table**: 상태 변경 + 이벤트 발행을 한 트랜잭션 내 처리
4. **Upsert / CAS**: DB 레벨 중복 방지

------

#### 서비스 경계와 데이터 중복

- **문제점**:
  - 데이터 중복 증가
  - 원격 조인으로 성능 저하·장애 전파
- **해결**:
  - Event-Carried State Transfer
  - 각 서비스 DB에서 직접 조회

------

#### 장애 및 복구 전략

- 재시도 시 지수 백오프 적용
- DLQ(Dead Letter Queue)로 처리 불가 메시지 격리
- 이벤트 소싱 기반 리플레이로 복구
- 모니터링: Saga ID, 트레이싱(OpenTelemetry)

------

#### 핵심 용어 정리

- **보상 트랜잭션(Compensation)**: SAGA 실패 시 이전 작업 취소
- **Command Model**: CQRS 쓰기 책임 모델
- **Query Model**: CQRS 읽기 책임 모델
- **Strong Consistency**: 즉시 일관성
- **Event Sourcing**: 상태 변경 이벤트 저장·재생
- **Choreography**: 분산 트랜잭션 이벤트 기반 자율 진행
- **Orchestration**: 중앙 조정자 기반 단계 관리

---

### 16. 시스템 분석/설계

#### MECE 원칙(Mutually Exclusive, Collectively Exhaustive)

- **정의**
  - **Mutually Exclusive**: 각 항목이 서로 중복되지 않음
  - **Collectively Exhaustive**: 전체 범위를 빠짐없이 포함
- **목적**
  - 분석·설계 단계에서 누락과 중복 방지
  - 신규 인력 투입 시 빠른 이해 가능
  - 테스트 케이스 완전성 확보
- **위반 시 위험**
  - 프로세스 중복 → 테스트 누락, 커뮤니케이션 오류
  - 시스템 통합 테스트 시 시나리오 누락 가능
- **관련 개념**
  - **WBS (Work Breakdown Structure)**: 프로젝트 작업 분할 시에도 MECE 적용
  - **반대 상황**: Overlap(중복) 또는 Gap(누락)

------

#### DB 연계와 영속 데이터 관리

- **정의**
  - **영속성(Persistence)**: 시스템 종료 후에도 유지되는 데이터
  - 분석·설계 단계에서 DB 연계 항목 명확히 식별
- **미도출 시 문제**
  - 통합 테스트 시 데이터 일관성 검증 불가
  - 초기화 데이터 누락, 실무 불일치
- **관련 개념**
  - **임시 데이터(Transient)**: 메모리에만 존재, 세션 종료 시 소멸
  - **DB 설계 시 고려**: 정규화, 무결성, 참조관계

------

#### UI 설계 산출물 & 탭 패턴 고려

- **UI 설계 산출물**
  1. **정보 구조도(IA)**: 정보 계층·접근 경로 설계
  2. **와이어프레임**: 화면 배치·흐름 설계
  3. **스토리보드**: 화면+데이터+이벤트 상세
- **탭 패턴 고려 사항**
  - 사용자별 접근 권한
  - 각 탭별 정보 계층/경로 논리적 구분
- **관련 개념**
  - **중앙집중 패턴**(Hub & Spoke)
  - **계층 패턴**(Hierarchy Pattern)

------

#### 상세 설계 vs 기본 설계

- **기본 설계**
  - 프로그램 개요, 기능 정의, 화면 설계
- **상세 설계**
  - 내부 호출 체계
  - 제어 로직, 데이터 구조 상세
- **관련 개념**
  - 기본 설계는 **무엇을** 만들지, 상세 설계는 **어떻게** 만들지
  - 반대되는 개념: 상위 레벨 설계 ↔ 하위 레벨 구현 설계

------

#### 통신 방법 & 데이터 형식

- **조건 매핑**
  - 실시간, 대용량, 구조화, 플랫폼 독립성
  - **Web Service + JSON** 적합
- **형식 특징**
  - JSON: 경량, 속성-값 구조
  - XML: 태그 기반, 복잡 구조 표현 가능, 무겁다
- **통신 방식 비교**
  - HTTP, WebSocket, Socket, FTP, DB Link
- **관련 개념**
  - 동기/비동기 통신
  - 구조화 데이터 vs 비구조화 데이터

------

#### 업무구성도 vs 업무흐름도

- **업무구성도**
  - 시스템 범위, 외부 인터페이스 시각화
  - 상위 단계에서 업무 기능 계층화
- **업무흐름도**
  - 프로세스 간 정보 흐름, 순서, 조건 표현
- **관련 개념**
  - 상위 모델 ↔ 상세 프로세스 모델
  - BPMN 다이어그램

------

#### 업무흐름도(Workflow Diagram) 주요 표기 요소

| 요소                           | 설명                                                         | 비고                                      |
| ------------------------------ | ------------------------------------------------------------ | ----------------------------------------- |
| **터미널 (Terminal)**          | 프로세스의 **시작(Start)** 또는 **종료(End)** 지점. 외부 사용자 또는 외부 시스템(시스템 경계 밖)을 나타냄. DFD(데이터 흐름도)나 일부 업무흐름도 표기법에서 사용. | UML·BPMN 표준에선 별도 기호로 표기        |
| **액터 (Actor)**               | 시스템 외부에서 시스템과 상호작용하는 주체(사람, 다른 시스템, 조직). 주로 **UML Use Case Diagram**에서 사용. | 업무흐름도에서 '터미널'과 개념적으로 유사 |
| **프로세스 (Process)**         | 업무 처리 단계, 기능 단위. 직사각형/둥근 사각형 등으로 표현. | 업무 기능 분해 결과물 반영                |
| **데이터 흐름 (Data Flow)**    | 데이터 이동 경로, 입력·출력. 화살표로 표현.                  | 흐름 방향 명확히 표시                     |
| **데이터 저장소 (Data Store)** | 데이터의 영속적 저장 위치(DB, 파일 등). 병렬선 또는 개방된 사각형 기호로 표현. |                                           |

------

#### 터미널(Terminal) vs 액터(Actor) 비교

| 구분             | 터미널 (Terminal)                                 | 액터 (Actor)                                  |
| ---------------- | ------------------------------------------------- | --------------------------------------------- |
| **주 사용 맥락** | 업무흐름도, DFD 등 절차·데이터 중심 모델링        | UML Use Case Diagram 등 행위·역할 중심 모델링 |
| **표시 대상**    | 외부 사용자, 외부 시스템, 프로세스 시작/종료 지점 | 외부 사용자, 외부 시스템, 조직 단위           |
| **표현 목적**    | 업무 프로세스의 경계와 시작/종료를 명확히 함      | 시스템과의 상호작용 주체 정의                 |
| **표기 형태**    | 원형, 타원형, 사각형(툴마다 다름)                 | 사람 모양, 직사각형, 스틱 피겨                |
| **비슷한 개념**  | External Entity(DFD)                              | Stakeholder, Role                             |

---

#### 핵심 선행 산출물

- **업무구성도**
  - 시스템 범위 정의
  - 이후 모든 설계·UI·인터페이스 설계의 기반
- **관련 개념**
  - E-R 다이어그램, 데이터 흐름도(DFD)

------

#### 전송방식 & 통신유형

- **전송방식**
  - 실시간(Real-time)
  - 지연처리(Deferred)
  - 배치(Batch)
- **통신유형**
  - 단방향(Notify)
  - 양방향(Sync)
- **조건 분석**
  - 불규칙 타이밍 + 응답 필수 + 송·수신 → **지연처리 + 양방향(Sync)**
- **반대 개념**
  - Polling: 주기적 요청 방식
  - Push: 서버가 클라이언트로 직접 전달

------

#### 정보 구조도 패턴

- **중앙집중 패턴(Hub & Spoke)**
  - 하나의 중심에서 여러 하위 정보로 연결
  - 대규모 포털, 통합 대시보드
- **대립 개념**
  - 계층형 패턴(Hierarchy)
  - 선형 패턴(Linear)
  - 완전 연결 패턴(Fully Connected)

------

#### 업무기능분해도 ↔ 통합업무흐름도 정합성

- **정합성 필요 이유**
  - 계층 구조와 전체 프로세스 흐름 일치
  - 누락/중복 방지
  - 테스트 커버리지 확보
- **관련 개념**
  - MECE 원칙
  - 프로세스 매핑

------

#### 주요 용어 요약

1. **MECE**: Mutually Exclusive, Collectively Exhaustive
2. **액터(Actor)**: 업무흐름도/BPMN에서 외부 사용자·시스템
3. **XML**: 태그 기반 계층 구조 데이터
4. **업무구성도**: 시스템 범위+외부 인터페이스 시각 표현
5. **Asynchronous**: 요청 후 즉시 다음 작업 수행, 응답은 나중에 콜백 처리

---

### 16. UML 기반 프로그램 분석/설계

#### UML 다이어그램 작성 및 활용 절차

- **유스케이스 다이어그램**
  - 요구사항 분석의 출발점, 액터와 시스템 기능 정의
  - 이후 시퀀스·클래스 다이어그램 설계의 기반
- **클래스 다이어그램**
  - 정적 구조 모델링 (속성, 메서드, 관계)
- **시퀀스 다이어그램**
  - 객체 간 메시지 흐름(동적 행위) 표현
- **액티비티 다이어그램**
  - 업무 절차, 조건, 병렬, 반복 흐름 표현
- **추천 순서**: **유즈케이스 → 클래스 → 시퀀스 → 액티비티**
- **대응 개념**: Top-down 분석 vs Bottom-up 설계

------

#### UML 클래스 다이어그램의 관계

| 관계                       | 설명                                     | 반대/대응 개념                          |
| -------------------------- | ---------------------------------------- | --------------------------------------- |
| **합성(Composition)**      | 전체-부분 관계, 전체 소멸 시 부분도 소멸 | 집합(Aggregation): 부분 독립 생존 가능  |
| **의존(Dependency)**       | 일시적 참조, 기능 의존                   | 연관(Association): 지속적 참조          |
| **일반화(Generalization)** | 상속 관계 (is-a)                         | 구현(Realization): 인터페이스 구현 관계 |

------

#### 시퀀스 다이어그램 제어 구조

- **alt**: 조건 분기(If-Else)
- **opt**: 단일 조건 실행(Optional)
- **loop**: 반복 구조
- **par**: 병렬 처리
- **조합 예시**: 동시성과 조건 분기를 동시에 → **par + alt**
- **대응 개념**: 순차 실행(seq), self 메시지(자기 호출)

------

#### 액티비티 다이어그램 종료 조건

- **포크(Fork)**: 흐름 병렬 분기
- **조인(Join)**: 모든 병렬 흐름이 완료되어야 합침
- **병합(Merge)**: 하나라도 완료 시 합침 (조건 병합)
- **조건**: “둘 중 하나라도 완료 시 종료” → Fork + Merge
- **대응 개념**: Fork+Join은 모든 흐름 완료 후 진행

------

#### 유즈케이스 다이어그램 액터 일반화

- **일반화(Generalization)**: 상위 액터 기능 상속
  - 일부 액터에만 추가 기능이 있을 때 사용
- **대응 개념**
  - Include 관계: 공통 기능 재사용
  - Extend 관계: 조건부 확장 기능

------

#### 다이어그램 선택 기준

- **액티비티 다이어그램**
  - 데이터 흐름 + 조건 분기 + 병렬 처리 + 반복 로직 표현 가능
  - 비즈니스 프로세스 모델링 적합
- **대응 개념**
  - 시퀀스 다이어그램: 메시지 중심
  - 상태 다이어그램: 상태 전이 중심

------

#### Boundary-Control-Entity (BCE) 패턴

- **Boundary**: UI, 외부 시스템 경계
- **Control**: 비즈니스 로직, 흐름 제어
- **Entity**: 데이터/영속 객체
- **장점**: 역할 분리 → 유지보수, 확장성 ↑
- **대응 개념**: MVC 패턴 (Model-View-Controller)

------

#### 시퀀스 ↔ 클래스 다이어그램 정합성 검증

- **오류 예시**: 시퀀스에서 호출한 메시지가 클래스 다이어그램 오퍼레이션에 없음
- **검증 포인트**:
  - 시퀀스 메시지 ↔ 클래스 메서드 매핑
- **대응 개념**: 속성 매핑 검증(클래스 ↔ 데이터모델)

------

#### 요구사항-구조-행위 UML 조합

- **요구사항 도출** → 유즈케이스 다이어그램
- **정적 구조 설계** → 클래스 다이어그램
- **동적 행위 설계** → 시퀀스 다이어그램
- **대응 개념**: 구조 다이어그램(정적) vs 행위 다이어그램(동적)

------

#### UML 범위와 생명주기 활용

- **구조 다이어그램**
  - 클래스, 컴포넌트, 배치, 패키지
- **행위 다이어그램**
  - 유즈케이스, 시퀀스, 액티비티, 상태, 커뮤니케이션
- **이점**: 설계~유지보수 전 단계에서 동일 모델 재활용
- **대응 개념**: 단발성 문서화 (UML 미사용 시)

------

#### 합성(Composition)

- **전체-부분 관계**, 전체 소멸 시 부분도 소멸
- **기호**: 채워진 마름모
- **대응 개념**: 집합(Aggregation, 빈 마름모)

------

#### 시퀀스 다이어그램 프래그먼트

- **Interaction Fragment**: opt, alt, loop, par 등 제어 구조 표현 블록
- **대응 개념**: 단순 메시지 교환 (제어 구조 없음)

------

#### 유즈케이스 다이어그램

- **목적**: 기능 정의, 범위 설정, 액터-기능 관계
- **활용**: 다른 다이어그램 시나리오 도출 기반
- **대응 개념**: 클래스 다이어그램(구조), 액티비티 다이어그램(행위 절차)

------

#### Boundary 클래스

- **의미**: 시스템 경계(UI, 외부 인터페이스)
- **BCE 패턴의 구성요소**
- **대응 개념**: Entity(데이터) 클래스, Control(로직) 클래스

------

#### 포크(Fork) / 조인(Join)

- **포크**: 병렬 분기
- **조인**: 병렬 합류
- **영문**: Fork Node / Join Node
- **대응 개념**: Merge Node(조건 합류), Decision Node(분기)

---