# Database Systems

### 데이터 모델링

#### 데이터 모델링의 정의와 목적

- **정의**: 현실 세계의 데이터를 추상화하여 **데이터 구조, 관계, 제약조건**을 설계하는 과정
- **목적**
  - **데이터의 일관성, 무결성, 중복 방지**
  - **업무 요구사항을 데이터 구조로 전환**
  - **DB 설계 → 구현 → 운영**의 기반 마련
- **DB 생명주기에서의 위치**
  - **설계 단계의 핵심 작업**이자,
  - **요구사항 분석 ↔ 구현 단계의 연결고리**
- **필요성**
  - 데이터 중복·불일치·이상현상(Anomaly) 사전 예방
  - 변경에 대한 대응 용이
  - SQL 성능 및 유지보수 효율성 향상

---

#### **추상화(Abstraction)**

- **정의**
  - 복잡한 현실 세계 데이터를 **필요한 요소만 선택하여 단순화·계층화**하는 과정
  - 데이터모델링의 각 단계(개념적→논리적→물리적)에서 **점진적으로 구체화**되는 특징을 설명하는 핵심 용어
- **단계별 추상화 수준**
  1. **개념적 모델링**: 추상화 최고 수준 → 엔티티·관계 정의
  2. **논리적 모델링**: 중간 수준 → 속성, 키, 정규화, 관계 상세화
  3. **물리적 모델링**: 추상화 최소 수준 → DBMS 구현 세부사항(데이터 타입, 인덱스 등)
- **이전 정리의 보완점**
  - Q27에서 "설계"는 단계의 명칭이 아니라, **단계별 구체화 과정을 설명하는 원리**는 추상화가 맞음

------

#### 데이터베이스 생명주기(DBLC: Database Life Cycle)

1. **요구사항 분석**
   - 업무 파악, 데이터 요구사항 정의
2. **설계**
   - **개념적 모델링** (추상화, ERD)
   - **논리적 모델링** (정규화, 속성 정의, 관계·키 정의)
   - **물리적 모델링** (DBMS 구현 세부사항 반영)
3. **구현**
   - 스키마 생성, 데이터 적재
4. **운영**
   - 데이터 활용, 유지보수
5. **감시 및 개선**
   - 성능·구조 개선, 모델 수정

------

#### 데이터 모델링 단계별 특징

| 구분              | 추상화 수준      | 주요 내용                                 | 산출물              | 반대/유사 개념       |
| ----------------- | ---------------- | ----------------------------------------- | ------------------- | -------------------- |
| **개념적 모델링** | 높음 (업무 중심) | 주요 엔티티·관계 도출, 업무규칙 반영      | ERD(개념 ERD)       | 물리적 모델링        |
| **논리적 모델링** | 중간 (DB 독립)   | 속성 정의, 키/외래키, 정규화, 관계 상세화 | 논리 ERD, 속성 목록 | 개념적/물리적 모델링 |
| **물리적 모델링** | 낮음 (DB 종속)   | 데이터 타입, 인덱스, 파티션, 스토리지     | DDL, 인덱스 설계서  | 개념적 모델링        |

**핵심 구분 기준**

- **논리적**: 데이터 구조의 **논리적 일관성**과 **정규화**
- **물리적**: **DBMS 구현 세부사항**(데이터 타입, 인덱스, 파티션, 제약조건)

------

#### 주요 용어

- **ERD(Entity Relationship Diagram)**: 엔티티·관계·속성을 시각적으로 표현한 다이어그램 (개념·논리 단계에서 사용)
- **정규화(Normalization)**: 데이터 중복과 이상현상 제거 → 무결성 확보
- **제약조건**
  - **PK(Primary Key)**: 엔티티의 유일성 보장
  - **FK(Foreign Key)**: 관계 무결성 유지
  - **UNIQUE**: 중복 방지
  - **NOT NULL**: 필수값 보장
- **인덱스(Index)**: 검색 성능 향상 (물리적 단계 산출물)
- **파티션(Partition)**: 데이터 물리적 분할 저장, 성능·관리 효율 향상

------

#### 단계별 주요 산출물 정리

| 단계       | 주요 산출물         | 포함 내용                                       |
| ---------- | ------------------- | ----------------------------------------------- |
| **개념적** | 개념 ERD            | 엔티티, 관계, 업무 규칙                         |
| **논리적** | 논리 ERD, 속성 목록 | 속성, 데이터 타입(논리 수준), 키/외래키, 정규화 |
| **물리적** | DDL 스크립트        | 데이터 타입(DBMS별), 인덱스, 파티션, 제약조건   |

------

#### 유사·반대 개념 매핑

| 개념          | 유사/연관              | 반대 개념           |
| ------------- | ---------------------- | ------------------- |
| 개념적 모델링 | 추상화, 업무 중심 설계 | 물리적 모델링       |
| 논리적 모델링 | 정규화, 속성·키 정의   | -                   |
| 물리적 모델링 | DBMS 구현, 인덱스      | 개념적 모델링       |
| PK            | 유일성 식별자          | 중복 허용 키(X)     |
| FK            | 참조 무결성            | 독립 테이블         |
| 정규화        | 이상현상 제거          | 비정규화(성능 목적) |

---

#### 함수 종속성(Function Dependency)

- **정의**: 속성 A의 값이 속성 B의 값을 유일하게 결정하는 관계 (A → B)
- **결정자(Determinant)**: A
- **종속자(Dependent)**: B
- **성립 조건**: A 값이 동일하면 B 값도 반드시 동일
- **정규화 기준**: 함수 종속성을 분석해 이상현상 제거 및 무손실 분해 수행
- **반대/연관 개념**: 다치 종속(Multivalued Dependency), 부분 종속, 이행 종속

------

#### 이상현상(Anomaly)

| 유형          | 설명                                         | 예시                                           |
| ------------- | -------------------------------------------- | ---------------------------------------------- |
| **삽입 이상** | 필요한 데이터를 일부만 입력 가능 → NULL 발생 | 주문 입력 시 고객정보 없으면 NULL              |
| **삭제 이상** | 한 데이터 삭제 시 관련 다른 정보까지 삭제    | 한 학생의 수강 내역 삭제 시 강의 정보까지 손실 |
| **수정 이상** | 중복 데이터 일부만 변경 → 불일치             | 동일 강좌 강의실 정보 일부만 수정됨            |

------

#### 정규화(Normalization)

**학원 수강 관리 정규화 스토리 (1NF → 2NF → 3NF → BCNF)**

**초기(정규화 전)**

문제: 한 셀에 여러 값(원자성 위반), 중복·이상 발생 가능

| 학생ID | 학생명 | 수강과목   | 강의실   | 강사명         |
| ------ | ------ | ---------- | -------- | -------------- |
| S1     | 김철수 | 수학, 영어 | 101, 102 | 홍길동, 이영희 |
| S2     | 박영희 | 과학       | 103      | 김민수         |

**1단계: 1NF(원자값 보장)**

규칙: 모든 속성은 더 쪼갤 수 없는 **원자값**

| 학생ID | 학생명 | 수강과목 | 강의실 | 강사명 |
| ------ | ------ | -------- | ------ | ------ |
| S1     | 김철수 | 수학     | 101    | 홍길동 |
| S1     | 김철수 | 영어     | 102    | 이영희 |
| S2     | 박영희 | 과학     | 103    | 김민수 |

- 여전히 **중복(학생명, 강사명)** 존재

**2단계: 2NF (부분 함수 종속 제거)**

가정: 기본키 = (학생ID, 수강과목)
규칙: 비키속성은 **키 전체**에 종속

분해 결과:

**학생**

| 학생ID | 학생명 |
| ------ | ------ |
| S1     | 김철수 |
| S2     | 박영희 |

**과목**

| 수강과목 | 강의실 | 강사명 |
| -------- | ------ | ------ |
| 수학     | 101    | 홍길동 |
| 영어     | 102    | 이영희 |
| 과학     | 103    | 김민수 |

**수강(교차/사실)**

| 학생ID | 수강과목 |
| ------ | -------- |
| S1     | 수학     |
| S1     | 영어     |
| S2     | 과학     |

- 부분종속 제거: `학생명`은 `학생ID`에만, `강의실/강사명`은 `수강과목`에만 종속

**3단계: 3NF (이행 종속 제거)**

문제: `수강과목 → 강의실 → 강사명` (비키→비키 이행 종속)

분해 결과:

**과목**

| 수강과목 | 강의실 |
| -------- | ------ |
| 수학     | 101    |
| 영어     | 102    |
| 과학     | 103    |

**강의실**

| 강의실 | 강사명 |
| ------ | ------ |
| 101    | 홍길동 |
| 102    | 이영희 |
| 103    | 김민수 |

- 이행 종속 제거로 **무결성 강화**

**4단계: BCNF (모든 결정자 = 후보키)**

가정 이슈: 만약 `강사명 → 강의실`이지만 `강사명`이 후보키가 아니면 BCNF 위반
 해결(결정자별 테이블 분리):

**강사**

| 강사명 | 강의실 |
| ------ | ------ |
| 홍길동 | 101    |
| 이영희 | 102    |
| 김민수 | 103    |

운영 규칙 명확화 예시

- **강의실당 1강사**(강의실→강사명) 또는 **강사당 1강의실**(강사명→강의실) 중 하나를 비즈니스 규칙으로 고정
- 규칙에 맞춰 후보키를 정하면 BCNF 충족 여부가 명확해짐
  - 예: “강의실은 담당 강사가 유일” → `강의실`이 후보키, 강의실 테이블이 BCNF

#### 최종 스키마(예시 FK 포함)

- **학생(학생ID PK, 학생명)**
- **과목(수강과목 PK, 강의실 FK→강의실.강의실)**
   또는 규칙에 따라 **과목(수강과목 PK)** 만 두고 **과목-강의실 매핑** 별도 테이블 운영
- **강의실(강의실 PK, 강사명 FK→강사.강사명)**
   *(규칙: 강의실당 한 명의 담당 강사)*
- **강사(강사명 PK)**
   *(규칙이 “강사 1인 1강의실”이면 강사에 강의실 FK)*
- **수강(학생ID FK→학생, 수강과목 FK→과목, PK=(학생ID, 수강과목))**

------

#### 요약 표

| 단계 | 제거 대상       | 변환 전 문제         | 변환 후 효과    |
| ---- | --------------- | -------------------- | --------------- |
| 1NF  | 다중값(비원자)  | 한 셀에 여러 값      | 원자값 보장     |
| 2NF  | 부분 종속       | 복합키 일부에만 종속 | 중복 감소       |
| 3NF  | 이행 종속       | 비키→비키 종속       | 무결성 강화     |
| BCNF | 비후보키 결정자 | 결정자가 후보키 아님 | 이상현상 최소화 |

**반대 개념**: 비정규화(Denormalization) – 성능 위해 중복 허용

------

#### 무손실 분해(Lossless Decomposition)

- **정의**: 분해된 릴레이션을 조인했을 때 원래 릴레이션이 완전히 복원되는 성질
- **조건**: 분해 릴레이션의 교집합이 적어도 한쪽의 **후보키**여야 함
- **연관 개념**: 종속성 보존(Dependency Preservation)

#### 무손실 분해 예시

##### 원래 릴레이션 R

`R(학번, 과목, 성적)`

| 학번 | 과목 | 성적 |
| ---- | ---- | ---- |
| S1   | DB   | A    |
| S1   | OS   | B    |
| S2   | DB   | C    |

##### 분해

- R1(학번, 과목)
- R2(학번, 성적)

##### 교집합 확인

- R1과 R2의 교집합 속성은 **학번**
- 하지만 학번은 R 전체 릴레이션의 **후보키가 아님** (→ 과목까지 있어야 후보키가 됨)

#### 조인 결과

`R1 ⋈ R2`

| 학번 | 과목 | 성적 |
| ---- | ---- | ---- |
| S1   | DB   | A    |
| S1   | DB   | B    |
| S1   | OS   | A    |
| S1   | OS   | B    |
| S2   | DB   | C    |

→ **원래 테이블보다 더 많은(잘못된) 튜플이 생성됨 → 무손실 분해 아님**

#### 무손실 분해가 되는 경우

##### 분해

- R1(학번, 과목)
- R2(과목, 성적)

##### 교집합 확인

- 교집합은 **과목**
- 과목은 **R에서 후보키가 아님 → 하지만 조건에 따라 가능**

##### 조인 결과

`R1 ⋈ R2`

| 학번 | 과목 | 성적 |
| ---- | ---- | ---- |
| S1   | DB   | A    |
| S1   | OS   | B    |
| S2   | DB   | C    |

→ **원래 테이블이 그대로 복원됨 → 무손실 분해 성립**

##### 정리

- **무손실 분해 조건**: R1 ∩ R2가 적어도 한쪽의 **후보키**를 포함해야 한다.
- 조건을 만족하지 않으면 **잘못된 튜플(Spurious Tuple)**이 생성된다.
- 따라서 **정규화 과정에서 가장 중요한 원칙** 중 하나가 바로 무손실 분해임.

------

#### 반대/연관 개념 정리

| 개념        | 반대/연관            |
| ----------- | -------------------- |
| 무손실 분해 | 정보 손실 분해       |
| 1NF         | 다중값 속성          |
| 2NF         | 부분 함수 종속       |
| 3NF         | 이행 함수 종속       |
| BCNF        | 후보키 아닌 결정자   |
| 함수 종속   | 다치 종속            |
| 정규화      | 비정규화             |
| 결정자      | 종속자               |
| 삽입 이상   | 삭제 이상, 수정 이상 |

---

#### 수직분할(Vertical Partitioning) ↔ 수평분할(Horizontal Partitioning)

**① 수직분할**

- **정의**: 컬럼 단위로 테이블을 나누는 기법
- **기준**: 컬럼 사용 빈도, 크기, 변경 빈도, 보안, 접근 패턴
- **장점**:
  - 자주 조회되는 컬럼만 모아 조회 성능 ↑
  - 변경 빈도 낮은 컬럼 분리 → Lock 경합 감소
  - 대용량 컬럼(BLOB, CLOB 등) 별도 저장 → 백업 효율 ↑
- **단점**:
  - JOIN 증가 → 부하 가능
- **예시**: 회원(기본), 회원인증, 회원접속이력, 회원사진

**② 수평분할**

- **정의**: 행 단위로 테이블을 나누는 기법
- **기준**: 날짜, 지역, ID 범위, 상태값 등
- **장점**:
  - 특정 구간 데이터만 조회 시 성능↑
  - 파티셔닝과 연계 가능
- **단점**:
  - 파티션 키 선정이 잘못되면 효과↓
- **예시**: 주문 테이블을 월별/지역별로 분할

------

#### 2차 정규화(2NF) ↔ 1NF / 3NF

**① 1차 정규화(1NF)**

- 정의: 모든 속성이 원자값(Atomic Value)만 가져야 함
- 예: 다중 값 컬럼 분리

**② 2차 정규화(2NF)**

- 정의: **부분 함수 종속 제거**
- 조건: 1NF 만족 + 기본키 전체 종속성 확보
- 예: (회원ID, 커뮤니티ID) → 회원명, 전화번호가 회원ID에만 종속 시 분리

**③ 3차 정규화(3NF)**

- 정의: **이행적 함수 종속 제거**
- 조건: 2NF 만족 + 비키 속성이 다른 비키 속성에 종속 금지
- 예: 고객 → 지역ID → 지역명 → 지역명은 지역 테이블로 이동

------

#### 자기참조(순환) 모델링 ↔ 계층 구조 모델링 방식 비교

**① 자기참조(Self-Referencing)**

- 한 테이블이 자기 자신의 PK를 FK로 참조
- 계층 구조 표현 (조직도, 메뉴 구조)
- 상위코드가 없는 최상위 노드는 FK NULL 허용

**② 다른 계층 구조 구현 방식**

- **Adjacency List**: 자기참조 모델 (가장 일반적)
- **Closure Table**: 모든 조상-자손 관계 저장 (계층 질의 성능↑, 저장공간↑)
- **Nested Set**: 좌우 인덱스 범위로 계층 표현 (읽기↑, 쓰기↓)
- **Materialized Path**: 경로 문자열로 계층 표현

------

#### 데이터 표준화 — 도메인 vs 단어사전 ↔ 표준화 미준수 시 문제

**① 도메인**

- 속성 타입, 길이, 허용값 범위 표준화
- 예: 금액 → NUMBER(10,2), 전화번호 → VARCHAR(15)

**② 단어사전**

- 컬럼명/테이블명 구성 단어 표준화
- 예: '회원', '주소', '전화번호' 표준 단어 지정

**③ 표준화 미준수 문제**

- 속성 중복, 데이터 불일치, 유지보수 비용 증가

------

#### 인덱스 ↔ 인덱스 부작용

**① 인덱스 장점**

- WHERE 조건, JOIN, ORDER BY, GROUP BY 성능↑

**② 인덱스 단점**

- DML 성능↓ (INSERT/UPDATE/DELETE 시 인덱스 재작성 필요)
- 저장공간 증가
- 너무 많은 인덱스는 오히려 전체 성능 저하

**③ 인덱스 종류**

- 단일 인덱스 / 복합 인덱스
- B-Tree 인덱스 / Bitmap 인덱스 / Hash 인덱스

------

#### 비즈니스키 ↔ 대체키

**① 비즈니스키**

- 업무에서 의미 있는 자연키 (주민번호, 사업자번호)
- 장점: 바로 의미 파악 가능
- 단점: 변경 가능성, 개인정보 위험

**② 대체키(Surrogate Key)**

- 의미 없는 인공키 (Sequence, UUID)
- 장점: 변경 없음, 보안성↑
- 단점: 값만 보고 의미 알 수 없음

------

#### 논리 모델링 ↔ 물리 모델링

| 구분   | 논리 모델링                 | 물리 모델링                   |
| ------ | --------------------------- | ----------------------------- |
| 초점   | 업무 규칙, 엔터티·속성·관계 | DBMS 구현 특성                |
| 산출물 | ERD, 엔터티 정의서          | 테이블 스키마, 인덱스, 파티션 |

------

#### 반정규화(De-normalization) ↔ 정규화

**① 반정규화**

- 성능 향상을 위해 정규화 원칙 일부 완화
- 중복 허용하여 JOIN 최소화
- 예: 코드값을 참조 대신 직접 저장

**② 정규화**

- 데이터 중복 최소화, 무결성 강화
- 예: 1NF, 2NF, 3NF

------

#### 파티셔닝 ↔ 테이블 분할

- **파티셔닝**: DBMS 레벨에서 물리적으로 데이터를 나누어 저장
  - 범위(Range), 해시(Hash), 리스트(List) 등
- **테이블 분할**: 논리 모델링 단계에서 테이블 자체를 나누는 설계

------

#### 주요 용어 요약

- **수직분할**: 컬럼 기준 테이블 분리
- **수평분할**: 행 기준 테이블 분리
- **정규화**: 데이터 중복 최소화
- **반정규화**: 성능 위해 중복 허용
- **도메인**: 데이터 타입/길이/범위 표준화
- **단어사전**: 명명 규칙 표준화
- **자기참조**: 테이블 내부 FK-PK 계층 관계
- **대체키**: 의미 없는 인공 PK
- **비즈니스키**: 의미 있는 자연 PK
- **인덱스**: 조회 성능 향상 구조 (DML 성능 저하 주의)

---

### ER 모델링

#### 엔티티(Entity)

- **정의**: 데이터베이스에서 관리해야 하는 객체(사람, 사물, 개념, 사건)
- **유형**
  - **강한 개체(Strong Entity)**: 고유 식별자(PK)로 독립 식별 가능
  - **약한 개체(Weak Entity)**: 상위 개체의 PK + 자신의 부분 키로만 식별 가능, ERD에서는 **이중 사각형**으로 표시
  - **문서 엔티티**: 전표·주문서 등 실제 문서 성격
  - **이력 엔티티**: 반복 사건 기록(입고 이력 등)
  - **코드 엔티티**: 기준정보(국가 코드, 부서 코드 등)
  - **유형/무형 엔티티**: 물리적 실체 존재 여부 기준

------

#### 속성(Attribute) & 도메인(Domain)

- **속성**: 엔티티의 성질을 나타내는 데이터 항목
- **도메인**: 속성 값의 **허용 범위와 데이터 타입** (값이 가질 수 있는 집합)
- **키 속성**
  - **기본키(PK)**: 엔티티 인스턴스 유일 식별
  - **외래키(FK)**: 다른 엔티티의 PK를 참조, 관계 무결성 보장

------

#### 관계(Relationship)

- **카디널리티(Cardinality)**: 엔티티 간 연관의 수적 제약
  - **1:1** / **1:N** / **M:N** (다대다, 실제 구현 시 중간 엔티티로 분해 필요)
- **참여 제약조건**
  - **전체참여(Total Participation)**: 모든 인스턴스가 반드시 관계에 참여 (**|** 표기, Chen 표기법에서는 이중선)
  - **선택참여(Optional Participation)**: 일부 인스턴스만 관계에 참여 가능 (**o** 표기)
- **식별 관계(Identifying Relationship)**: 약한 개체와 강한 개체를 연결, 약한 개체의 PK 일부 구성
  - **표기**: **실선 (solid line)**
  - **의미**: 자식 엔티티의 **PK가 부모 엔티티의 PK를 반드시 포함**해야 함
  - **예시**:
    - `LoginInfo` 엔티티가 `Member` 엔티티의 PK(member_id)를 포함하는 경우
    - 즉, `LoginInfo`의 기본키는 (`member_id`, `login_time`) 같이 부모 PK + 추가 속성으로 구성
- **비식별 관계(Non-identifying Relationship)**: FK는 존재하지만 PK에 포함되지 않음
  - **표기**: **점선 (dashed line)**
  - **의미**: 자식 엔티티의 **PK는 독립적**, 부모 PK는 단지 **FK로만 존재**
  - **예시**:
    - `Reply` 엔티티가 `Board` 엔티티의 PK(board_id)를 **FK로만** 가지고 있고,
       자신의 PK는 독립적으로 (`reply_id`) 유지되는 경우

------

#### 표기법

- **피터 첸(Chen) 표기법**: 엔티티(사각형), 속성(타원), 관계(마름모)
- **IE 표기법**: 엔티티·속성(사각형), 관계선과 **o**, **|** 기호로 카디널리티·참여 제약 표시
  - `o` : 선택참여
  - `|` : 전체참여

------

#### 특수 관계

- **ISA 관계**: 상위 엔티티를 하위 엔티티로 세분화(일반화/특수화)
  예: 상위 엔티티(직원)을 여러 하위 엔티티(정규직, 계약직) 등으로 세분화하여 공통 속성과 개별 속성을 효율적으로 관리
- **자기참조 관계**: 동일 엔티티 내부에서의 관계

------

#### 정규화

- **목적**: 데이터 중복, 이상현상(갱신·삽입·삭제) 제거 → 무결성 확보
- **단계**: 1NF(원자값) → 2NF(부분 함수 종속 제거) → 3NF(이행 함수 종속 제거) → BCNF…

------

#### 논리적 모델링에서 제약조건의 역할

- **NOT NULL**: 필수값
- **UNIQUE**: 중복 방지
- **PK/FK**: 유일성·관계 무결성
- **CHECK**: 값 범위 제한

------

#### 반대/유사 개념 정리

| 개념            | 반대/유사 개념     |
| --------------- | ------------------ |
| 강한 개체       | 약한 개체          |
| 전체참여(Total) | 선택참여(Optional) |
| 1:N             | 1:1, M:N           |
| M:N             | 1:1, 1:N           |
| 식별 관계       | 비식별 관계        |
| ISA 관계        | 단순 관계          |
| 정규화          | 비정규화           |
| 도메인          | 속성 값            |

---

### 데이터베이스 구현과 물리적 모델링

#### 논리적 모델링 vs 물리적 모델링

- **논리적 모델링(Logical Modeling)**
  - 엔티티(개체), 속성, 관계를 **추상적 구조(ERD)**로 표현
  - **정규화**를 통해 데이터 중복 최소화, 무결성 확보
  - DBMS에 독립적 → 특정 제품에 구애받지 않음
- **물리적 모델링(Physical Modeling)**
  - 논리 모델을 실제 **DBMS 특성에 맞게 구현**
  - 테이블, 인덱스, 파티션, 테이블스페이스, 저장 구조 설계
  - 성능·저장 효율 고려 (B-Tree, Fulltext 인덱스, 파티셔닝 등)
  - DBMS 종속적 → MySQL, Oracle, MSSQL마다 다름

> 반대되는 관계:
>
> - 논리적 모델링은 **개념적 모델링**과 물리적 모델링의 중간단계
> - 논리적 모델링이 **"무엇을 저장할 것인가"**, 물리적 모델링이 **"어떻게 저장할 것인가"**

------

#### 제약조건(Constraints)

- **Primary Key(PK)**
  - 한 행(Row)을 유일하게 식별
  - 중복 X, NULL X
  - 자동으로 인덱스 생성됨
- **Unique**
  - 중복 X, NULL 허용 (단 NULL은 여러 개 가능)
  - PK와 달리 한 테이블에 여러 개 지정 가능
- **Not Null**
  - NULL 입력 불가
- **Foreign Key(FK)**
  - 다른 테이블의 PK를 참조
  - **ON DELETE CASCADE** → 부모 삭제 시 자식 행 자동 삭제
  - **ON UPDATE CASCADE** → 부모 키 변경 시 자식 값 자동 변경
- **Check**
  - 특정 조건을 만족하는 값만 입력 허용
  - 예: `CHECK(age >= 0)`

> 유사·대조 개념
>
> - PK vs Unique → 둘 다 유일성 보장, 하지만 **NULL 허용 여부** 다름
> - FK vs Join → FK는 무결성 제약조건, Join은 조회 시 관계 결합

------

#### 인덱스(Index)

- **B-Tree 인덱스**
  - 가장 일반적인 인덱스(정렬, 범위 검색 최적화)
  - `=` 검색, `BETWEEN`, `ORDER BY`에 유리
- **Fulltext 인덱스**(MySQL, Oracle Text 등)
  - 텍스트 기반 검색 최적화 (자연어 검색, LIKE 대비 효율적)
  - 단점: 삽입·수정 시 인덱스 재구성이 느림
  - Fulltext 인덱스는 MySQL의 MyISAM, InnoDB 등 일부 스토리지 엔진에서 지원되는 특수 인덱스
- **Clustered Index**
  - PK를 기준으로 실제 데이터 페이지가 정렬 저장
  - MySQL InnoDB → PK 자동 Clustered Index
- **Bitmap Index**(Oracle 등)
  - 값의 종류가 적은 경우 유리 (성별, Y/N 플래그)

> 비교 개념
>
> - **인덱스 vs 파티셔닝**: 인덱스는 "검색 속도 향상", 파티셔닝은 "데이터 분산 관리"
> - **Clustered vs Non-Clustered**: Clustered는 데이터 자체가 정렬됨, Non-Clustered는 별도 포인터 유지

------

#### 파티셔닝(Partitioning)

- **정의**: 대용량 테이블을 논리적으로 분할 → 물리적으로 여러 공간에 저장
- **목적**: 특정 조건(날짜, 범위 등)에 따라 빠른 검색과 관리 효율성 확보
- **종류**
  - Range Partitioning (범위별)
  - List Partitioning (목록별)
  - Hash Partitioning (해시 알고리즘 기반)
  - Composite Partitioning (복합 방식)

> 비교 개념
>
> - **Sharding**: 애플리케이션 레벨에서 DB 자체를 분산 → 다른 서버에 저장
> - **Partitioning**: 하나의 DB 내에서 분할

------

#### 트랜잭션과 ACID

- **Atomicity(원자성)**: 모두 실행 or 전혀 실행 안 됨
- **Consistency(일관성)**: 무결성 제약조건 항상 만족
- **Isolation(고립성)**: 동시에 실행되는 트랜잭션이 서로 간섭하지 않음
- **Durability(지속성)**: Commit된 결과는 영구 보존
- **트랜잭션 격리 수준** (Isolation Levels, SQL 표준)
  1. Read Uncommitted → Dirty Read 발생 가능
  2. Read Committed → Dirty Read 방지, Non-repeatable Read 가능
  3. Repeatable Read → Non-repeatable Read 방지, Phantom Read 가능
  4. Serializable → 완벽한 고립성, 성능 저하

> 비교 개념
>
> - 동시성 제어 방식: **Locking vs MVCC(Multi-Version Concurrency Control)**
>   - MySQL InnoDB는 MVCC 사용 → 읽기/쓰기 충돌 완화

------

#### SQL 객체 및 용어

- **View**: 실제 저장되지 않고, 쿼리 결과를 가상 테이블로 제공
- **Tablespace**: DB 저장공간을 논리적으로 나눈 단위(Oracle, MySQL InnoDB 등)
- **Auto Increment**: PK가 자동 증가하도록 설정(`AUTO_INCREMENT` in MySQL)