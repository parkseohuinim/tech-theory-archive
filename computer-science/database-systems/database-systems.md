# Database Systems

### 1. 데이터 모델링

#### 데이터 모델링의 정의와 목적

- **정의**: 현실 세계의 데이터를 추상화하여 **데이터 구조, 관계, 제약조건**을 설계하는 과정
- **목적**
  - **데이터의 일관성, 무결성, 중복 방지**
  - **업무 요구사항을 데이터 구조로 전환**
  - **DB 설계 → 구현 → 운영**의 기반 마련
- **DB 생명주기에서의 위치**
  - **설계 단계의 핵심 작업**이자,
  - **요구사항 분석 ↔ 구현 단계의 연결고리**
- **필요성**
  - 데이터 중복·불일치·이상현상(Anomaly) 사전 예방
  - 변경에 대한 대응 용이
  - SQL 성능 및 유지보수 효율성 향상

---

#### **추상화(Abstraction)**

- **정의**
  - 복잡한 현실 세계 데이터를 **필요한 요소만 선택하여 단순화·계층화**하는 과정
  - 데이터모델링의 각 단계(개념적→논리적→물리적)에서 **점진적으로 구체화**되는 특징을 설명하는 핵심 용어
- **단계별 추상화 수준**
  1. **개념적 모델링**: 추상화 최고 수준 → 엔티티·관계 정의
  2. **논리적 모델링**: 중간 수준 → 속성, 키, 정규화, 관계 상세화
  3. **물리적 모델링**: 추상화 최소 수준 → DBMS 구현 세부사항(데이터 타입, 인덱스 등)
- **이전 정리의 보완점**
  - Q27에서 "설계"는 단계의 명칭이 아니라, **단계별 구체화 과정을 설명하는 원리**는 추상화가 맞음

------

#### 데이터베이스 생명주기(DBLC: Database Life Cycle)

1. **요구사항 분석**
   - 업무 파악, 데이터 요구사항 정의
2. **설계**
   - **개념적 모델링** (추상화, ERD)
   - **논리적 모델링** (정규화, 속성 정의, 관계·키 정의)
   - **물리적 모델링** (DBMS 구현 세부사항 반영)
3. **구현**
   - 스키마 생성, 데이터 적재
4. **운영**
   - 데이터 활용, 유지보수
5. **감시 및 개선**
   - 성능·구조 개선, 모델 수정

------

#### 데이터 모델링 단계별 특징

| 구분              | 추상화 수준      | 주요 내용                                 | 산출물              | 반대/유사 개념       |
| ----------------- | ---------------- | ----------------------------------------- | ------------------- | -------------------- |
| **개념적 모델링** | 높음 (업무 중심) | 주요 엔티티·관계 도출, 업무규칙 반영      | ERD(개념 ERD)       | 물리적 모델링        |
| **논리적 모델링** | 중간 (DB 독립)   | 속성 정의, 키/외래키, 정규화, 관계 상세화 | 논리 ERD, 속성 목록 | 개념적/물리적 모델링 |
| **물리적 모델링** | 낮음 (DB 종속)   | 데이터 타입, 인덱스, 파티션, 스토리지     | DDL, 인덱스 설계서  | 개념적 모델링        |

**핵심 구분 기준**

- **논리적**: 데이터 구조의 **논리적 일관성**과 **정규화**
- **물리적**: **DBMS 구현 세부사항**(데이터 타입, 인덱스, 파티션, 제약조건)

------

#### 주요 용어

- **ERD(Entity Relationship Diagram)**: 엔티티·관계·속성을 시각적으로 표현한 다이어그램 (개념·논리 단계에서 사용)
- **정규화(Normalization)**: 데이터 중복과 이상현상 제거 → 무결성 확보
- **제약조건**
  - **PK(Primary Key)**: 엔티티의 유일성 보장
  - **FK(Foreign Key)**: 관계 무결성 유지
  - **UNIQUE**: 중복 방지
  - **NOT NULL**: 필수값 보장
- **인덱스(Index)**: 검색 성능 향상 (물리적 단계 산출물)
- **파티션(Partition)**: 데이터 물리적 분할 저장, 성능·관리 효율 향상

------

#### 단계별 주요 산출물 정리

| 단계       | 주요 산출물         | 포함 내용                                       |
| ---------- | ------------------- | ----------------------------------------------- |
| **개념적** | 개념 ERD            | 엔티티, 관계, 업무 규칙                         |
| **논리적** | 논리 ERD, 속성 목록 | 속성, 데이터 타입(논리 수준), 키/외래키, 정규화 |
| **물리적** | DDL 스크립트        | 데이터 타입(DBMS별), 인덱스, 파티션, 제약조건   |

------

#### 유사·반대 개념 매핑

| 개념          | 유사/연관              | 반대 개념           |
| ------------- | ---------------------- | ------------------- |
| 개념적 모델링 | 추상화, 업무 중심 설계 | 물리적 모델링       |
| 논리적 모델링 | 정규화, 속성·키 정의   | -                   |
| 물리적 모델링 | DBMS 구현, 인덱스      | 개념적 모델링       |
| PK            | 유일성 식별자          | 중복 허용 키(X)     |
| FK            | 참조 무결성            | 독립 테이블         |
| 정규화        | 이상현상 제거          | 비정규화(성능 목적) |

---

#### 수직분할(Vertical Partitioning) ↔ 수평분할(Horizontal Partitioning)

**① 수직분할**

- **정의**: 컬럼 단위로 테이블을 나누는 기법
- **기준**: 컬럼 사용 빈도, 크기, 변경 빈도, 보안, 접근 패턴
- **장점**:
  - 자주 조회되는 컬럼만 모아 조회 성능 ↑
  - 변경 빈도 낮은 컬럼 분리 → Lock 경합 감소
  - 대용량 컬럼(BLOB, CLOB 등) 별도 저장 → 백업 효율 ↑
- **단점**:
  - JOIN 증가 → 부하 가능
- **예시**: 회원(기본), 회원인증, 회원접속이력, 회원사진

**② 수평분할**

- **정의**: 행 단위로 테이블을 나누는 기법
- **기준**: 날짜, 지역, ID 범위, 상태값 등
- **장점**:
  - 특정 구간 데이터만 조회 시 성능↑
  - 파티셔닝과 연계 가능
- **단점**:
  - 파티션 키 선정이 잘못되면 효과↓
- **예시**: 주문 테이블을 월별/지역별로 분할

------

#### 2차 정규화(2NF) ↔ 1NF / 3NF

**① 1차 정규화(1NF)**

- 정의: 모든 속성이 원자값(Atomic Value)만 가져야 함
- 예: 다중 값 컬럼 분리

**② 2차 정규화(2NF)**

- 정의: **부분 함수 종속 제거**
- 조건: 1NF 만족 + 기본키 전체 종속성 확보
- 예: (회원ID, 커뮤니티ID) → 회원명, 전화번호가 회원ID에만 종속 시 분리

**③ 3차 정규화(3NF)**

- 정의: **이행적 함수 종속 제거**
- 조건: 2NF 만족 + 비키 속성이 다른 비키 속성에 종속 금지
- 예: 고객 → 지역ID → 지역명 → 지역명은 지역 테이블로 이동

------

#### 자기참조(순환) 모델링 ↔ 계층 구조 모델링 방식 비교

**① 자기참조(Self-Referencing)**

- 한 테이블이 자기 자신의 PK를 FK로 참조
- 계층 구조 표현 (조직도, 메뉴 구조)
- 상위코드가 없는 최상위 노드는 FK NULL 허용

**② 다른 계층 구조 구현 방식**

- **Adjacency List**: 자기참조 모델 (가장 일반적)
- **Closure Table**: 모든 조상-자손 관계 저장 (계층 질의 성능↑, 저장공간↑)
- **Nested Set**: 좌우 인덱스 범위로 계층 표현 (읽기↑, 쓰기↓)
- **Materialized Path**: 경로 문자열로 계층 표현

------

#### 데이터 표준화 — 도메인 vs 단어사전 ↔ 표준화 미준수 시 문제

**① 도메인**

- 속성 타입, 길이, 허용값 범위 표준화
- 예: 금액 → NUMBER(10,2), 전화번호 → VARCHAR(15)

**② 단어사전**

- 컬럼명/테이블명 구성 단어 표준화
- 예: '회원', '주소', '전화번호' 표준 단어 지정

**③ 표준화 미준수 문제**

- 속성 중복, 데이터 불일치, 유지보수 비용 증가

------

#### 인덱스 ↔ 인덱스 부작용

**① 인덱스 장점**

- WHERE 조건, JOIN, ORDER BY, GROUP BY 성능↑

**② 인덱스 단점**

- DML 성능↓ (INSERT/UPDATE/DELETE 시 인덱스 재작성 필요)
- 저장공간 증가
- 너무 많은 인덱스는 오히려 전체 성능 저하

**③ 인덱스 종류**

- 단일 인덱스 / 복합 인덱스
- B-Tree 인덱스 / Bitmap 인덱스 / Hash 인덱스

------

#### 비즈니스키 ↔ 대체키

**① 비즈니스키**

- 업무에서 의미 있는 자연키 (주민번호, 사업자번호)
- 장점: 바로 의미 파악 가능
- 단점: 변경 가능성, 개인정보 위험

**② 대체키(Surrogate Key)**

- 의미 없는 인공키 (Sequence, UUID)
- 장점: 변경 없음, 보안성↑
- 단점: 값만 보고 의미 알 수 없음

------

#### 논리 모델링 ↔ 물리 모델링

| 구분   | 논리 모델링                 | 물리 모델링                   |
| ------ | --------------------------- | ----------------------------- |
| 초점   | 업무 규칙, 엔터티·속성·관계 | DBMS 구현 특성                |
| 산출물 | ERD, 엔터티 정의서          | 테이블 스키마, 인덱스, 파티션 |

------

#### 반정규화(De-normalization) ↔ 정규화

**① 반정규화**

- 성능 향상을 위해 정규화 원칙 일부 완화
- 중복 허용하여 JOIN 최소화
- 예: 코드값을 참조 대신 직접 저장

**② 정규화**

- 데이터 중복 최소화, 무결성 강화
- 예: 1NF, 2NF, 3NF

------

#### 파티셔닝 ↔ 테이블 분할

- **파티셔닝**: DBMS 레벨에서 물리적으로 데이터를 나누어 저장
  - 범위(Range), 해시(Hash), 리스트(List) 등
- **테이블 분할**: 논리 모델링 단계에서 테이블 자체를 나누는 설계

------

#### 주요 용어 요약

- **수직분할**: 컬럼 기준 테이블 분리
- **수평분할**: 행 기준 테이블 분리
- **정규화**: 데이터 중복 최소화
- **반정규화**: 성능 위해 중복 허용
- **도메인**: 데이터 타입/길이/범위 표준화
- **단어사전**: 명명 규칙 표준화
- **자기참조**: 테이블 내부 FK-PK 계층 관계
- **대체키**: 의미 없는 인공 PK
- **비즈니스키**: 의미 있는 자연 PK
- **인덱스**: 조회 성능 향상 구조 (DML 성능 저하 주의)

---